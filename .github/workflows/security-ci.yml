name: Security CI (Reusable)

on:
  workflow_call:
    inputs:
      run_gitleaks:
        type: boolean
        default: true
      run_semgrep:
        type: boolean
        default: true
      run_trivy_fs:
        type: boolean
        default: true
      run_trivy_image:
        type: boolean
        default: false

      trivy_severity:
        type: string
        default: "HIGH,CRITICAL"

      image_ref:
        type: string
        required: false

      run_dast_zap:
        type: boolean
        default: false
      zap_target:
        type: string
        default: "http://localhost:8080"

permissions:
  contents: read
  packages: read

jobs:
  gitleaks:
    if: ${{ inputs.run_gitleaks }}
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure reports folder
        run: mkdir -p reports

      - name: Gitleaks scan (JSON)
        shell: bash
        run: |
          docker run --rm \
            -v "${PWD}:/repo" \
            zricethezav/gitleaks:latest detect \
              --source="/repo" \
              --no-git \
              --redact \
              --report-format json \
              --report-path "/repo/reports/gitleaks.json" || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/gitleaks.json ] || echo "{}" > reports/gitleaks.json

      - name: Upload Gitleaks report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: reports/gitleaks.json

  semgrep:
    if: ${{ inputs.run_semgrep }}
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure reports folder
        run: mkdir -p reports

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Semgrep
        shell: bash
        run: |
          python -m pip install --upgrade pip
          pip install semgrep
          semgrep --version

      - name: Semgrep scan (JSON)
        shell: bash
        run: |
          semgrep scan --config p/default --json -o reports/semgrep.json . || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/semgrep.json ] || echo "{}" > reports/semgrep.json

      - name: Upload Semgrep report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-report
          path: reports/semgrep.json

  trivy_fs:
    if: ${{ inputs.run_trivy_fs }}
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure reports folder
        run: mkdir -p reports

      - name: Trivy filesystem scan (JSON)
        shell: bash
        run: |
          docker run --rm \
            -v "${PWD}:/work" \
            -w /work \
            aquasec/trivy:latest fs \
              --scanners vuln,secret,misconfig \
              --severity "${{ inputs.trivy_severity }}" \
              --format json \
              --output reports/trivy-fs.json \
              /work || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/trivy-fs.json ] || echo "{}" > reports/trivy-fs.json

      - name: Upload Trivy FS report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-fs-report
          path: reports/trivy-fs.json

  trivy_image:
    if: ${{ inputs.run_trivy_image }}
    runs-on: self-hosted
    steps:
      - name: Ensure reports folder
        run: mkdir -p reports

      - name: Validate image_ref
        shell: bash
        run: |
          if [ -z "${{ inputs.image_ref }}" ]; then
            echo "image_ref is required when run_trivy_image=true"
            exit 2
          fi

      - name: Log in to GHCR
        shell: bash
        run: |
          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Pull image
        run: docker pull "${{ inputs.image_ref }}"

      - name: Trivy image scan (JSON)
        shell: bash
        run: |
          docker run --rm \
            -v "${PWD}:/work" \
            -w /work \
            aquasec/trivy:latest image \
              --severity "${{ inputs.trivy_severity }}" \
              --format json \
              --output reports/trivy-image.json \
              "${{ inputs.image_ref }}" || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/trivy-image.json ] || echo "{}" > reports/trivy-image.json

      - name: Upload Trivy Image report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-image-report
          path: reports/trivy-image.json

    dast_zap:
    # Runs when either baseline or active is requested
    if: ${{ inputs.run_dast_zap || inputs.run_dast_zap_active }}
    runs-on: self-hosted
    timeout-minutes: 35
    steps:
      - name: Docker access check
        shell: bash
        run: |
          set -euo pipefail
          id
          docker info

      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure reports folder
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p reports

      - name: Preflight - ensure port 8080 is free
        shell: bash
        run: |
          set -euo pipefail

          echo "== Docker containers publishing 8080 =="
          docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | (head -n 1; grep -E "0\.0\.0\.0:8080->|:::8080->" || true)

          ids="$(docker ps -q --filter "publish=8080" || true)"
          if [ -n "${ids}" ]; then
            echo "Stopping containers publishing 8080: ${ids}"
            docker stop ${ids} || true
            docker rm -f ${ids} || true
          fi

          echo "== Host processes listening on 8080 (if any) =="
          if command -v ss >/dev/null 2>&1; then
            ss -ltnp | grep -E ":8080\s" || true
            if ss -ltnp | grep -qE ":8080\s"; then
              echo "ERROR: Port 8080 is still in use by a host process. Stop that service on the runner."
              exit 1
            fi
          elif command -v lsof >/dev/null 2>&1; then
            lsof -iTCP:8080 -sTCP:LISTEN || true
            if lsof -iTCP:8080 -sTCP:LISTEN >/dev/null 2>&1; then
              echo "ERROR: Port 8080 is still in use by a host process. Stop that service on the runner."
              exit 1
            fi
          else
            echo "Neither ss nor lsof available. Skipping host process check."
          fi

      - name: Start app via docker compose
        shell: bash
        run: |
          set -euo pipefail
          export COMPOSE_PROJECT_NAME="demoapp_${{ github.run_id }}_${{ github.run_attempt }}"
          docker compose -f docker-compose.ci.yml up -d --build
          docker compose -f docker-compose.ci.yml ps

      - name: Wait for app health (debug-friendly)
        shell: bash
        run: |
          set -euo pipefail
          URL="${{ inputs.zap_target }}/health"
          echo "Waiting for: $URL"

          for i in $(seq 1 90); do
            code="$(curl -s -o /tmp/health_body.txt -w "%{http_code}" "$URL" || true)"
            if [ "$code" = "200" ]; then
              echo "App is healthy (200)"
              exit 0
            fi

            echo "Attempt $i: HTTP $code"
            echo "Body:"
            head -n 40 /tmp/health_body.txt || true
            sleep 2
          done

          echo "App did not become healthy. Showing compose status + logs:"
          docker compose -f docker-compose.ci.yml ps || true
          docker compose -f docker-compose.ci.yml logs --no-color --tail=300 || true
          exit 1

      - name: ZAP Baseline (passive)
        if: ${{ inputs.run_dast_zap }}
        shell: bash
        run: |
          set -euo pipefail
          docker run --rm \
            --network host \
            -v "${PWD}:/zap/wrk" \
            zaproxy/zap-stable \
            zap-baseline.py \
              -t "${{ inputs.zap_target }}" \
              -I \
              -s \
              -r reports/zap-baseline.html \
              -J reports/zap-baseline.json || true

      - name: ZAP Active (full scan)
        if: ${{ inputs.run_dast_zap_active }}
        shell: bash
        run: |
          set -euo pipefail
          docker run --rm \
            --network host \
            -v "${PWD}:/zap/wrk" \
            zaproxy/zap-stable \
            zap-full-scan.py \
              -t "${{ inputs.zap_target }}" \
              -a \
              -j \
              -r reports/zap-active.html \
              -J reports/zap-active.json || true

      - name: Ensure ZAP report files exist
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p reports
          [ -f reports/zap-baseline.html ] || echo "<html><body>No baseline report generated</body></html>" > reports/zap-baseline.html
          [ -f reports/zap-baseline.json ] || echo "{}" > reports/zap-baseline.json
          [ -f reports/zap-active.html ] || echo "<html><body>No active report generated</body></html>" > reports/zap-active.html
          [ -f reports/zap-active.json ] || echo "{}" > reports/zap-active.json
          echo "== reports/ contents =="
          ls -la reports

      - name: Upload ZAP reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-reports
          path: |
            reports/zap-*.html
            reports/zap-*.json
          if-no-files-found: warn


      - name: Tear down
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          export COMPOSE_PROJECT_NAME="demoapp_${{ github.run_id }}_${{ github.run_attempt }}"
          docker compose -f docker-compose.ci.yml down -v --remove-orphans || true
