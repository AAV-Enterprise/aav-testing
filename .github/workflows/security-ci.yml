name: Security CI (Reusable)

on:
  workflow_call:
    inputs:
      run_gitleaks:
        type: boolean
        default: true
      run_semgrep:
        type: boolean
        default: true
      run_trivy_fs:
        type: boolean
        default: true
      run_trivy_image:
        type: boolean
        default: false
      trivy_severity:
        type: string
        default: "HIGH,CRITICAL"
      image_ref:
        type: string
        required: false
      run_dast_zap:
        type: boolean
        required: false
        default: false
      run_dast_zap_active:
        type: boolean
        required: false
        default: false
      zap_target:
        type: string
        required: false
        default: "http://app:8080"
    secrets:
      ZAP_USER:
        required: false
      ZAP_PASS:
        required: false

permissions:
  contents: read
  packages: read

jobs:
  gitleaks:
    if: ${{ inputs.run_gitleaks }}
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure reports folder
        run: mkdir -p reports

      - name: Gitleaks scan (JSON)
        shell: bash
        run: |
          docker run --rm \
            -v "${PWD}:/repo" \
            zricethezav/gitleaks:latest detect \
              --source="/repo" \
              --no-git \
              --redact \
              --report-format json \
              --report-path "/repo/reports/gitleaks.json" || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/gitleaks.json ] || echo "{}" > reports/gitleaks.json

      - name: Upload report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: reports/gitleaks.json
          if-no-files-found: warn

  semgrep:
    if: ${{ inputs.run_semgrep }}
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: Ensure reports folder
        run: mkdir -p reports

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Semgrep
        shell: bash
        run: |
          python -m pip install --upgrade pip
          pip install semgrep
          semgrep --version

      - name: Semgrep scan (JSON)
        shell: bash
        run: |
          semgrep scan --config p/default --json -o reports/semgrep.json . || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/semgrep.json ] || echo "{}" > reports/semgrep.json

      - name: Upload report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-report
          path: reports/semgrep.json
          if-no-files-found: warn

  trivy_fs:
    if: ${{ inputs.run_trivy_fs }}
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: Ensure reports folder
        run: mkdir -p reports

      - name: Trivy filesystem scan (JSON)
        shell: bash
        run: |
          docker run --rm \
            -v "${PWD}:/work" \
            -w /work \
            aquasec/trivy:latest fs \
              --scanners vuln,secret,misconfig \
              --severity "${{ inputs.trivy_severity }}" \
              --format json \
              --output reports/trivy-fs.json \
              /work || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/trivy-fs.json ] || echo "{}" > reports/trivy-fs.json

      - name: Upload report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-fs-report
          path: reports/trivy-fs.json
          if-no-files-found: warn

  trivy_image:
    if: ${{ inputs.run_trivy_image }}
    runs-on: self-hosted
    steps:
      - name: Ensure reports folder
        run: mkdir -p reports

      - name: Validate image_ref
        shell: bash
        run: |
          if [ -z "${{ inputs.image_ref }}" ]; then
            echo "image_ref is required when run_trivy_image=true"
            exit 2
          fi

      - name: Log in to GHCR
        shell: bash
        run: |
          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Pull image
        run: docker pull "${{ inputs.image_ref }}"

      - name: Trivy image scan (JSON)
        shell: bash
        run: |
          docker run --rm \
            -v "${PWD}:/work" \
            -w /work \
            aquasec/trivy:latest image \
              --severity "${{ inputs.trivy_severity }}" \
              --format json \
              --output reports/trivy-image.json \
              "${{ inputs.image_ref }}" || true

      - name: Ensure report exists
        if: always()
        run: |
          [ -f reports/trivy-image.json ] || echo "{}" > reports/trivy-image.json

      - name: Upload report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-image-report
          path: reports/trivy-image.json
          if-no-files-found: warn

  dast_zap:
    if: ${{ inputs.run_dast_zap || inputs.run_dast_zap_active }}
    runs-on: self-hosted
    timeout-minutes: 45

    steps:
      - uses: actions/checkout@v4

      - name: Docker access check
        shell: bash
        run: |
          set -euo pipefail
          docker info

      - name: Start app via docker compose
        shell: bash
        run: |
          set -euo pipefail
          export COMPOSE_PROJECT_NAME="demoapp_${{ github.run_id }}_${{ github.run_attempt }}"
          docker compose -f docker-compose.ci.yml up -d --build
          docker compose -f docker-compose.ci.yml ps

      - name: Detect compose network
        shell: bash
        run: |
          set -euo pipefail
          export COMPOSE_PROJECT_NAME="demoapp_${{ github.run_id }}_${{ github.run_attempt }}"
          NET="${COMPOSE_PROJECT_NAME}_default"
          echo "COMPOSE_NET=${NET}" >> "$GITHUB_ENV"
          docker network ls | grep -F "$NET" || (echo "Network $NET not found" && exit 1)

      - name: Wait for health (inside compose net)
        shell: bash
        run: |
          set -euo pipefail
          URL="${{ inputs.zap_target }}/health"
          for i in $(seq 1 90); do
            if docker run --rm --network "${COMPOSE_NET}" curlimages/curl:8.5.0 -fsS "$URL" >/dev/null 2>&1; then
              echo "healthy"
              exit 0
            fi
            sleep 2
          done
          docker compose -f docker-compose.ci.yml logs --no-color --tail=200 || true
          exit 1

      - name: Ensure reports folder
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p reports
          ls -la reports

      - name: Debug login from inside compose net
        shell: bash
        run: |
          set -euo pipefail
          docker run --rm --network "${COMPOSE_NET}" curlimages/curl:8.5.0 -i -s \
            -c /tmp/cookies.txt \
            -d "username=${{ secrets.ZAP_USER }}&password=${{ secrets.ZAP_PASS }}" \
            "${{ inputs.zap_target }}/login" | head -n 60

          echo "Cookies:"
          docker run --rm --network "${COMPOSE_NET}" curlimages/curl:8.5.0 -s \
            -c /tmp/cookies.txt -o /dev/null \
            -d "username=${{ secrets.ZAP_USER }}&password=${{ secrets.ZAP_PASS }}" \
            "${{ inputs.zap_target }}/login" >/dev/null || true


      - name: ZAP full
        if: ${{ inputs.run_dast_zap_active }}
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          docker run --rm \
            --network "${COMPOSE_NET}" \
            -v "${PWD}:/zap/wrk:rw" \
            -w /zap/wrk \
            -e ZAP_USER="${{ secrets.ZAP_USER }}" \
            -e ZAP_PASS="${{ secrets.ZAP_PASS }}" \
            -e NO_PROXY="app,db,127.0.0.1,localhost" \
            -e no_proxy="app,db,127.0.0.1,localhost" \
            zaproxy/zap-stable \
            bash -lc '
              set -e
              chmod +x zap/run_zap_full.sh
              TARGET="${{ inputs.zap_target }}" \
              ZAP_REPORT="zap-full" \
              ZAP_ALERT_REPORT="zap-full-alerts" \
              zap/run_zap_full.sh
            '
          echo "FULL_EXIT=$?" >> "$GITHUB_ENV"

      - name: Upload reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-reports
          path: reports/
          if-no-files-found: warn

      - name: Tear down
        if: always()
        shell: bash
        run: |
          export COMPOSE_PROJECT_NAME="demoapp_${{ github.run_id }}_${{ github.run_attempt }}"
          docker compose -f docker-compose.ci.yml down -v --remove-orphans || true

      - name: DAST gate (fail if baseline/full found Medium/High)
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          BASE="${BASELINE_EXIT:-0}"
          FULL="${FULL_EXIT:-0}"

          echo "Baseline exit: $BASE"
          echo "Full exit:     $FULL"

          # Dacă ai rulat baseline și/sau full și oricare a găsit Medium/High (scriptul tău dă 1),
          # atunci fail final:
          if [ "$BASE" -ne 0 ] || [ "$FULL" -ne 0 ]; then
            echo "DAST gate: FAIL (issues detected)."
            exit 1
          fi

          echo "DAST gate: PASS."

